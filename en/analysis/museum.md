Working with Museum Data
========================

To make edits non-destructive,
data in OpenStreetMap is not truely deleted but superseded by newer versions.
We explain here the details about that mechanism
and how to retrieve other than recent data with the Overpass API.

<a name="date"/>
## A Point in Time

It is possible to retrieve old states of data.
A simple and illustrative example is to view [former buildings and highways](https://overpass-turbo.eu/?lat=51.525&lon=-0.25&zoom=16&Q=CGI_STUB) at the Old Oak construction site in London: 

    [date:"2018-01-01T00:00:00Z"];
    (
      way[highway]({{bbox}});
      way[building]({{bbox}});
    );
    out geom;

As you can see, some buildings match the background rendering, i.e. current buildings.
Some current buildings miss from the results which means that they have not been mapped at that date.
And some buldings no longer exist, as they had occupied the same space where now the construction site is situated.

You can play a little bit with the date (from 2013 to today) to see how the existing data varied.

<a name="museum_model"/>
## Museum Data Structures

There are quite a number of data structures that seemingly interrelate with data version control.

First of all, each node, way, and relation has a version number,
and older versions of elements are in general available through the main API or other data sources.
Then there are changesets including meta information and comments.
Finally, each element version has attached a timestamp to it.

<a name="changesets"/>
### Changesets

Changesets are designed to let the mapper group changes as they see fit.
A changeset can be open up to 24 hours.
A traditional paradigm on changesets would be that they are stacked one over the other,
and the stack can be undone up to the point where the unwanted change sits.
This is deeply in conflict with geographic structuring,
because one for sure does not want to undo unrelated changes at the other end of the world to fix a local mistake.
On the other hand, formal interdepence is a too restrictive point of view,
as one absolutely might have aligned element A to element B in changeset X,
while element B itself comes from changeset Y.
Then there is no formal, but well a factual dependency of A on B, thus X on Y.

Multiple changesets can be entangled. Have a look at [node 6551935928](https://overpass-turbo.eu/?lat=51.49824&lon=-0.06385&zoom=20&Q=CGI_STUB):
Go to the data tab and scroll through the versions of date 2021-08-13.
The query itslef is explained alongside *timeline* and *retro* further below.

    timeline(node,6551935928);
    for (t["created"])
    {
      retro (_.val)
      {
        node(6551935928);
        out meta;
      }
    }

Version 7 belongs to changeset 109621973.
Then versions 8 and 9 belong to changeset 109622477.
Versions 10 and 11 again belong to changeset 109621973, while finally version 12 belongs to changeset 109622477.
I.e. changeset 109621973 depends on changeset 109622477, but changeset 109622477 also depends on changeset 109621973.

There exist at least over a thousand of such simply mutual interpendencies on the same element.
But there exist also circular dependencies or dependencies involving multiple elements.

As a consequence of this, it is usually but not always possible at all to revert a single changeset
even if one were to accept the other problems of the stack metaphor.

Changesets comment may still be instructive on what was intended with a changeset.
However, the quality of changeset comments varies wildly.
Quite a number of changeset comments are autogenerated by the editing software or otherwise unhelpful information.

<a name="versions"/>
### Version Numbers

So are version numbers the right concept?

It has already been mentioned that geographic interdependencies happen between elements
and are hard to spot on a single element.
But there are more blatant problems:
The *StreetMap* in OpenStreetMap suggests that it is about giving geometry to ways,
but ways have only references to node ids.
As a result, the geometry of a way can change without the way getting a new version.

See for example here. This is [way 14259870 version 4](https://overpass-turbo.eu/?lat=52.4318&lon=13.5338&zoom=20&Q=CGI_STUB) at 2013-01-01:

    [date:"2013-01-01T00:00:00Z"];
    way(142598705);
    out geom meta;

This is [the same way 14259870 in the same version 4](https://overpass-turbo.eu/?lat=52.4318&lon=13.5338&zoom=20&Q=CGI_STUB). With different geometry at timestamp 2019-01-01:

    [date:"2019-01-01T00:00:00Z"];
    way(142598705);
    out geom;


It is widespread: I've made an analysis based on the data as of 2023-01-26 21:48,
and 147 447 805 of 916 422 831 ways have at least one version with multiple geometries.
This is more than 15% of all ways.

To safely determine the geomtry of a way and changes to it, version numbers are unfit.

Remarkably, relations suffer from the opposite problem when trying to track changes on them:
If someone splits a way which is member of a relation for whatever reason
then this creates a new version of the relation.
At least a somewhat justified new version is created when a minor geometry change happens somewhere on a relation.
If one tracks change in a local area of some kilometers diameter then there is almost sure
that those minor geometry changes
that have happened on a long relation elsewhere drastically outnumber relevant changes.

In other words: treating relations for change tracking as modified by their version number has a bad signal-to-noise ratio.
On top of this, relations inherit the problem that changes to the way
that do not result in a changed relation member list do not increment the relation version.
In other words, the problem is both a lot of noise and the absence of the desired signal.

<a name="timestamps"/>
### Timestamps

For the reasons mentioned before, the Overpass API relies for museum data on timestamps.

As [shown above](#date), one can add the prefix `[date:"YYYY-MM-DDThh:mm:ssZ"]` before the query
to run the query towards the data as of the provided date.
The `T` and `Z` are fixed markers and indicate that always UTC is used as reference;
the `YYYY-MM-DD` is the date in exactly that order and `hh:mm:ss` is the time in exactly that format.
Please note that you need exactly one single semicolon at the end of the one or more prefixes,
and that multiple prefixes like `[date:...]`, `[timeout:...]`, and `[out:...]` [are not separated](https://overpass-turbo.eu/?lat=51.525&lon=-0.25&zoom=16&Q=CGI_STUB) by semicolons:

    [date:"2013-01-01T00:00:00Z"][timeout:30];
    (
      way[highway]({{bbox}});
      way[building]({{bbox}});
    );
    out geom;

The advantage of the timestamp paradigm is that it is conceptually simple:
You see the geometry of ways (and state of relation members) in a then consistent combination,
nonwithstanding whether asynchronous changes mean that a different geomtry applies to the same way version at a different point in time.

The data of the timestamp when a mapper has started a changeset is what they have started working on.
The data of the timestamp when a mapper has finished a changeset usually is what they have deemed complete,
but there is no guarantee that the mapper has actually reviewed what they had produced.

In principle, it is possible that edits of multiple mappers within an area and the short time span of a changeset overlap.
But in practice this has hardly been ever observed.
Either it is so close that a conflict prevented the second mapper from completing the upload
or the edits of the two mappers have been separated enough to tell the apart.

While it is in principle also possible to spot a change by downloading two data states of the points in time before and after a change or a reference period,
there are server side tools available to reduce the amount of data to handle,
see next section.

<a name="diff-adiff"/>
## Select Changed Data

...

<a name="diff-only"/>
### Patch Data

...

<a name="adiff"/>
### Whereabouts

...

<a name="compare"/>
### Specific Differences

...

<a name="timeline"/>
## Plot an Element over Time

...
timeline
retro

<a name="josm"/>
## Unearthing with JOSM

Before you handcraft too much, a short reminder:
if your want to revert a complete changeset then the reverter plugin does this more reliable than manual work.

It is possible to edit removed data back into OpenStreetMap, although some caveats apply.
The basic process is to load the former data into JOSM and then copy over the elements one wants back to life.
Unless manual tweaking this applies new ids to the copied objects.

Make sure that you have turned on the Expert Mode in the JOSM settings.

Figure out the exact extent of the region (bounding box) and date that you want to reactivate data from.
Change the tab in the download dialogue to *Download from Overpass API*.
You can then download your data of interest with a request like

    [date:"$TIMESTAMP"];
    (
      nwr({{bbox}});
      node(w);
    );
    out meta;

This is the old data you can copy from.

Now go once again to the download dialogue and erase the request from the textfield.
This way you get the current data in the same bounding box.

You must download via *Download as a new layer*.
Only that way you have the current data in a proper data layer.

Now you can switch between the two layers by using the layers pane (Alt-Shift+L).
Turn the old state layer active by putting the check mark there and click if necessary the eye to get unobstructed view.
Copy from there what you want to reactivate. To save topology, do so in one step.
Turn the current state layer active by putting the check mark there and paste into that layer.

Now you have the reactivated objects as new objects there.
If they need to be welded into existing objects when do so now.
Finally, you can upload or complete the editing session with related edits.
As changesets should make clear intent, it is usually unhelpful
to mix a recontruction operation with genuinely new editing.
