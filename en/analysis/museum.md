Working with Museum Data
========================

To make edits non-destructive,
data in OpenStreetMap is not truely deleted but superseded by newer versions.
We explain here the details about that mechanism
and how to retrieve other than recent data with the Overpass API.

<a name="date"/>
## A Point in Time

It is possible to retrieve old states of data.
A simple and illustrative example is to view [former buildings and highways](https://overpass-turbo.eu/?lat=51.525&lon=-0.25&zoom=16&Q=CGI_STUB) at the Old Oak construction site in London: 

    [date:"2018-01-01T00:00:00Z"];
    (
      way[highway]({{bbox}});
      way[building]({{bbox}});
    );
    out geom;

As you can see, some buildings match the background rendering, i.e. current buildings.
Some current buildings miss from the results which means that they have not been mapped at that date.
And some buldings no longer exist, as they had occupied the same space where now the construction site is situated.

You can play a little bit with the date (from 2013 to today) to see how the existing data varied.

<a name="museum_model"/>
## Museum Data Structures

There are quite a number of data structures that seemingly interrelate with data version control.

First of all, each node, way, and relation has a version number,
and older versions of elements are in general available through the main API or other data sources.
Then there are changesets including meat information and comments.
Finally, each element version has attached a timestamp to it.

<a name="changesets"/>
### Changesets

Changesets are designed to let the mapper group changes as they see fit.
A changeset can be open up to 24 hours.
A traditional paradigm on changesets would be that they are stacked one over the other,
and the stack can be undone up to the point where the unwanted change sits.
This is deeply in conflict with geographic structuring,
because one for sure does not want to undo unrelated changes at the other end of the world to fix a local mistake.
On the other hand, formal interdepence is a too restrictive point of view,
as one absolutely might have aligned element A to element B in changeset X,
while element B itself comes from changeset Y.
Then there is no formal, but well a factual dependency of A on B, thus X on Y.

Multiple changesets can be entangled, i.e. changeset A contains say version 1 of an object, then changeset B contains version 2 of an object, and finally again changeset A contains version 3 of the same object.
As a result, it is usually but not always possible at all to revert a single changeset
even if one were to accepting the other problems of the stack metaphor.

... Interrelated changesets? ...

Changesets comment may still be instructive on what was intended with a changeset.
However, the quality of changeset comments varies wildly.
Quite a number of changeset comments are autogenerated by the editing software or otherwise unhelpful information.

<a name="versions"/>
### Version Numbers

So are version numbers the right concept?

It has already been mentioned that geographic interdependencies happen between elements
and are hard to spot on a single element.
But there are more blatant problems:
The *StreetMap* in OpenStreetMap suggests that it is about giving geometry to ways,
but ways have only references to node ids.
As a result, the geometry of a way can change without the way getting a new version.

See for example here. This is [way 14259870 version 4](https://overpass-turbo.eu/?lat=52.4318&lon=13.5338&zoom=20&Q=CGI_STUB) at 2013-01-01:

    [date:"2013-01-01T00:00:00Z"];
    way(142598705);
    out geom meta;

This is [the same way 14259870 in the same version 4](https://overpass-turbo.eu/?lat=52.4318&lon=13.5338&zoom=20&Q=CGI_STUB). With different geometry at timestamp 2019-01-01:

    [date:"2019-01-01T00:00:00Z"];
    way(142598705);
    out geom;


It is widespread: I've made an analysis based on the data as of 2023-01-26 21:48,
and 147 447 805 of 916 422 831 ways have at least one version with multiple geometries.
This is more than 15% of all ways.

To safely determine the geomtry of a way and changes to it, version numbers are unfit.

Remarkably, relations suffer from the opposite problem when trying to trck changes on them:
If someone splits a way which is member of a relation for whatever reason
then this creates a new version of the relation.
At least a somewhat justified new version is created when a minor geometry change happens somewhere on a relation.
If one tracks change in a local area of some kilometers diameter then there is a close-to-one chance
that those minor geomtrey changes have happened on a long relation elsewhere drastically outnumber relevant changes.

In other words: treating relations for change tracking as modified by their version number has an extremely bad signal-to-noise ratio.
On top of this, relations inherit the problem that changes to the way
that do not result in a changed relation member list do not increment the relation version.
In other words, the problem is both a lot of noise and the absence of the desired signal.

<a name="timestamps"/>
### Timestamps

...

<a name="foo"/>
## Foo

...

Diff
Adiff
compare

timeline
retro

<a name="josm"/>
## Unearthing with JOSM

Before you handcraft too much, a short reminder:
if your want to revert a complete changeset then the reverter plugin does this more reliable than manual work.

It is possible to edit removed data back into OpenStreetMap, although some caveats apply.
The basic process is to load the former data into JOSM and then copy over the elements one wants back to life.
Unless manual tweaking this applies new ids to the copied objects.

Make sure that you have turned on the Expert Mode in the JOSM settings.

Figure out the exact extent of the region (bounding box) and date that you want to reactivate data from.
Change the tab in the download dialogue to *Download from Overpass API*.
You can then download your data of interest with a request like

    [date:"$TIMESTAMP"];
    (
      nwr({{bbox}});
      node(w);
    );
    out meta;

This is the old data you can copy from.

Now go once again to the download dialogue and erase the request from the textfield.
This way you get the current data in the same bounding box.

You must download via *Download as a new layer*.
Only that way you have the current data in a proper data layer.

Now you can switch between the two layers by using the layers pane (Alt-Shift+L).
Turn the old state layer active by putting the check mark there and click if necessary the eye to get unobstructed view.
Copy from there what you want to reactivate. To save topology, do so in one step.
Turn the current state layer active by putting the check mark there and paste into that layer.

Now you have the reactivated objects as new objects there.
If they need to be welded into existing objects when do so now.
Finally, you can upload or complete the editing session with related edits.
As changesets should make clear intent, it is usually unhelpful
to mix a recontruction operation with genuinely new editing.
